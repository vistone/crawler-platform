package GoogleEarth

import (
	"fmt"
	"math/rand/v2"
)

// Auth Google Earth 认证管理器
type Auth struct {
	Session string // 认证会话 ID（从 Cookie 中提取的 sessionid）
}

// ClearAuth 清除当前的认证会话信息
func (a *Auth) ClearAuth() {
	a.Session = ""
}

// GetSession 获取当前的 session（如果已认证）
func (a *Auth) GetSession() string {
	return a.Session
}

// ParseSessionFromResponse parseSessionFromResponse 从响应 body 中解析 sessionid
// 响应格式：前 8 字节为头部，之后是以 NULL 结尾的 sessionid 字符串
// 这个 sessionid 会被保存到热连接中，后续所有请求都会自动携带
func ParseSessionFromResponse(responseBody []byte) (string, error) {
	if len(responseBody) <= 8 {
		return "", fmt.Errorf("响应 body 长度不足，实际长度为 %d 字节", len(responseBody))
	}

	// 从第 8 字节开始提取 sessionid（直到遇到 NULL 字节）
	var sessionBytes []byte
	for i := 8; i < len(responseBody); i++ {
		if responseBody[i] == 0 {
			break
		}
		sessionBytes = append(sessionBytes, responseBody[i])
	}

	if len(sessionBytes) == 0 {
		return "", fmt.Errorf("未找到有效的 sessionid 数据")
	}

	return string(sessionBytes), nil
}

// 预定义的 Google Earth 认证密钥
var (
	// GEAUTH1 - 版本 0x03
	GEAUTH1 = []byte{
		0x03, 0x00, 0x00, 0x00, 0x02, 0xf1, 0x5b, 0x5e, 0x34, 0x86, 0x84, 0x38, 0x4f, 0xb9, 0x04, 0x0a,
		0x3a, 0xbf, 0x5e, 0x6a, 0x8d, 0x85, 0x3c, 0x6a, 0x3f, 0xaa, 0xd0, 0xf1, 0x77, 0x47, 0x6f, 0x6f,
		0x67, 0x6c, 0x65, 0x45, 0x61, 0x72, 0x74, 0x68, 0x57, 0x69, 0x6e, 0x2e, 0x65, 0x78, 0x65, 0x00,
	}

	// GEAUTH2 - 版本 0x01
	GEAUTH2 = []byte{
		0x01, 0x00, 0x00, 0x00, 0x02, 0xf1, 0x5b, 0x5e, 0x34, 0x86, 0x84, 0x38, 0x4f, 0xb9, 0x04, 0x0a,
		0x3a, 0xbf, 0x5e, 0x6a, 0x8d, 0xec, 0xc2, 0xa8, 0x1c, 0x43, 0x08, 0xc5, 0x77, 0x58, 0xe0, 0x48,
		0x9d, 0x8b, 0x80, 0xdb, 0x4d, 0x00, 0x06, 0x25, 0x31, 0x93, 0xaf, 0x8e, 0xf6, 0xfb, 0x0a, 0xa9,
		0x8b,
	}

	// GEAUTH3 - 版本 0x01
	GEAUTH3 = []byte{
		0x01, 0x00, 0x00, 0x00, 0x02, 0x72, 0xb7, 0x97, 0x7b, 0xae, 0x42, 0x3e, 0x43, 0x8b, 0x26, 0x19,
		0xca, 0xae, 0x24, 0x5b, 0x9f, 0x03, 0x29, 0xf2, 0xa6, 0xc4, 0x0e, 0x8d, 0x22, 0x5c, 0xd6, 0xf1,
		0x71, 0x12, 0x7c, 0xe0, 0xc7, 0x00, 0x06, 0x25, 0x31, 0x83, 0x5e, 0x79, 0x5c, 0xdc, 0x37, 0x19,
		0xc8,
	}
)

// GenerateRandomGeAuth 生成指定版本的认证密钥（用于测试和自定义）
// version: 版本号（0x01-0xFF）
//   - 如果 version = 0，从预定义密钥中随机选择一个
//   - 如果 version = 1, 2, 3，返回对应的 GEAUTH1/2/3
//   - 其他版本号，生成带该版本号的随机密钥
//
// 返回：48 或 49 字节的认证密钥
func GenerateRandomGeAuth(version byte) ([]byte, error) {
	// version = 0：从预定义密钥中随机选择
	if version == 0 {
		keys := [][]byte{GEAUTH1, GEAUTH2, GEAUTH3}
		return keys[rand.IntN(len(keys))], nil
	}

	// version = 1, 2, 3：返回对应的预定义密钥
	switch version {
	case 1:
		return GEAUTH2, nil // GEAUTH2 的版本是 0x01
	case 2:
		return GEAUTH3, nil // GEAUTH3 的版本也是 0x01，但数据不同
	case 3:
		return GEAUTH1, nil // GEAUTH1 的版本是 0x03
	}

	// 其他版本号：根据预定义密钥的规律生成新的密钥
	// 分析规律：
	// 1. 前5字节固定格式：[version, 0x00, 0x00, 0x00, 0x02]
	// 2. GEAUTH1和GEAUTH2的前16字节（索引5-15）相同，但GEAUTH3不同
	// 3. GEAUTH1是48字节（包含"GoogleEarthWin.exe\0"），GEAUTH2和GEAUTH3是49字节
	// 4. 从索引16开始的数据是随机的，但需要保持合理的分布

	header := []byte{version, 0x00, 0x00, 0x00, 0x02}

	// 生成随机数据部分（44字节）
	// 为了保持与预定义密钥类似的特性，我们生成完全随机的数据
	data := make([]byte, 44)
	for i := range data {
		data[i] = byte(rand.IntN(256))
	}

	// 组合：header(5) + randomData(44) = 49字节
	return append(header, data...), nil
}
